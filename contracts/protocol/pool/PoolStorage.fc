#include "../../imports/stdlib.fc";
#include "../logic/calculate_supply.fc";

;; Load the storage
(cell) load_storage() inline {
    slice ds = get_data().begin_parse();
    if (ds.slice_empty?()) {
        ;; If storage is empty, return new empty dictionary
        return new_dict();
    }
    return ds~load_dict();
}

() save_storage(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) {
    ;; Parse sender address from message
    slice cs = in_msg_full.begin_parse();
    cs~skip_bits(4); ;; skip flags
    slice sender_address = cs~load_msg_addr();
    
    ;; Load existing dictionary
    cell dict = load_storage();
    
    ;; Get existing supply for this address if any
    (slice value, int success) = dict.udict_get?(256, sender_address.preload_uint(256));
    int current_supply = 0;
    if (success) {
        current_supply = value~load_coins();
    }
    
    ;; Add new supply to existing amount
    int new_supply = current_supply + msg_value;
    
    ;; Store updated supply amount
    dict~udict_set(
        256, ;; key length for address (256 bits)
        sender_address.preload_uint(256), ;; address as key
        begin_cell().store_coins(new_supply).end_cell().begin_parse() ;; store amount as coins
    );
    
    ;; Save updated dictionary to storage
    set_data(
        begin_cell()
            .store_dict(dict)
        .end_cell()
    );
    
    return();
}

;; Helper function to get user's supply
(int) get_user_supply(slice user_address) inline {
    cell dict = load_storage();
    (slice value, int success) = dict.udict_get?(256, user_address.preload_uint(256));
    if (success == 0) {
        return 0;
    }
    return value~load_coins();
}